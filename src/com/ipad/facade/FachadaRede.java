/* * Copyright (C) 2007-2009 the GSAN - Sistema Integrado de Gestão de Serviços de Saneamento * * This file is part of GSAN, an integrated service management system for Sanitation * * GSAN is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License. * * GSAN is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA *//* * GSAN - Sistema Integrado de Gestão de Serviços de Saneamento * Copyright (C) <2007>  * Adriano Britto Siqueira * Alexandre Santos Cabral * Ana Carolina Alves Breda * Ana Maria Andrade Cavalcante * Aryed Lins de Araújo * Bruno Leonardo Rodrigues Barros * Carlos Elmano Rodrigues Ferreira * Clêudio de Andrade Lira * Denys Guimarães Guenes Tavares * Eduardo Breckenfeld da Rosa Borges * Fabíola Gomes de Araújo * Flêvio Leonardo Cavalcanti Cordeiro * Francisco do Nascimento Júnior * Homero Sampaio Cavalcanti * Ivan Sérgio da Silva Júnior * José Edmar de Siqueira * José Thiago Tenório Lopes * Kássia Regina Silvestre de Albuquerque * Leonardo Luiz Vieira da Silva * Márcio Roberto Batista da Silva * Maria de Fátima Sampaio Leite * Micaela Maria Coelho de Araújo * Nelson Mendonça de Carvalho * Newton Morais e Silva * Pedro Alexandre Santos da Silva Filho * Rafael Corrêa Lima e Silva * Rafael Francisco Pinto * Rafael Koury Monteiro * Rafael Palermo de Araújo * Raphael Veras Rossiter * Roberto Sobreira Barbalho * Roberto Souza * Rodrigo Avellar Silveira * Rosana Carvalho Barbosa * Sávio Luiz de Andrade Cavalcante * Tai Mu Shih * Thiago Augusto Souza do Nascimento * Tiago Moreno Rodrigues * Vivianne Barbosa Sousa * * Este programa é software livre; você pode redistribuí-lo e/ou * modificá-lo sob os termos de Licença Pública Geral GNU, conforme * publicada pela Free Software Foundation; versão 2 da * Licença. * Este programa é distribuído na expectativa de ser útil, mas SEM * QUALQUER GARANTIA; sem mesmo a garantia implêcita de * COMERCIALIZAÇÃO ou de ADEQUAÇÃO A QUALQUER PROPÓSITO EM * PARTICULAR. Consulte a Licença Pública Geral GNU para obter mais * detalhes. * Você deve ter recebido uma cópia da Licença Pública Geral GNU * junto com este programa; se não, escreva para Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA * 02111-1307, USA. */package com.ipad.facade;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.util.Vector;import com.ipad.io.MessageDispatcher;import com.ipad.util.Util;/** * A classe FachadaRede agrupa serviços que precisam da rede. Ela conecta quando * necessário, envia os dados para o servidor, recebe a resposta do servidor e * repassa para o listener. *  * @author Rafael Palermo de Araújo */public class FachadaRede {    public static boolean indcConfirmacaRecebimento = false;    /**     * Identificador da requisição Cliente->Servidor de confirmar recebimento do     * roteiro.     */    public static final byte CS_CONFIRMAR_RECEBIMENTO = 3;    // Identificadores das requisições    private static final byte PACOTE_BAIXAR_ARQUIVO = 0;    private static final byte PACOTE_ATUALIZAR_MOVIMENTO = 1;    private static final byte PACOTE_FINALIZAR_LEITURA = 2;    private static final byte PACOTE_CONFIRMAR_ARQUIVO_RECEBIDO = 3;    private static final byte BAIXAR_NOVA_VERSAO_JAD = 4;    private static final byte BAIXAR_NOVA_VERSAO_JAR = 5;        private boolean requestOK = false;    /**     * IMEI (International Mobile Equipment Identifier) do dispositivo.     */    private long imei;    /**     * Com base no padrão de Projeto chamado Singleton, FachadaRede tem apenas     * uma única instância em todo o contexto da aplicação.     */    private static FachadaRede instance;    /**     * Despachante das mensagens de requisição de serviço para o servidor.     */    private static MessageDispatcher dispatcher;    /**     * Cria uma instância do objeto FachadaRede.     */    private FachadaRede() {	FachadaRede.dispatcher = MessageDispatcher.getInstancia();    }    /**     * Retorna a instância da fachada de rede.     *      * @return A instância da fachada de rede.     */    public static FachadaRede getInstancia() {	if (FachadaRede.instance == null) {	    FachadaRede.instance = new FachadaRede();	}	return FachadaRede.instance;    }    /**     * Repassa as requisições ao servidor.     *      * @param parametros     *            Vetor de parâmetros da operação.     * @param recebeResposta     *            Boolean que diz se recebe ou não um InputStream do servidor     */    public void iniciarServicoRede(Vector parametros, boolean enviarIMEI) {	byte[] serverMsg = null;	if (enviarIMEI) {	    // adiciona o IMEI como segundo parâmetro da mensagem	    parametros.insertElementAt(new Long(this.getIMEI()), 1);	}	// transforma os parâmetros em array de bytes para enviar	serverMsg = Util.empacotarParametros(parametros);	// envia menssagem para o servidor	dispatcher.setMensagem(serverMsg);	dispatcher.enviarMensagem();	requestOK = MessageDispatcher.getRespostaServidor() == MessageDispatcher.RESPOSTA_OK;    }    /**     * Alterar a url do servidor     **/    public void setURL(String url) {	dispatcher.setURL_SERVIDOR(url);    }    /**     * Retorna o IMEI (International Mobile Equipment Identifier) do     * dispositivo.     *      * @return O IMEI do dispositivo.     */    public long getIMEI() {	if (this.imei == 0) {	    // chamada proprietária da NOKIA	    String strIMEI = System.getProperty("com.nokia.mid.imei");	    if (strIMEI == null){	    	strIMEI = "356837024186111";	    }	    if (strIMEI != null) {	    	this.imei = Long.parseLong(strIMEI);	    }	}	return this.imei;    }    /**     * Solicita o envio dos dados dos ultimos imoveis com atualizacoes pendentes     * para o servidor.     *      * @param listener     *            Objeto que aguarda a resposta da operacao.     */    public void confirmarRecebimentoArquivo() {	// cria o vetor de parametros	Vector param = new Vector();	// adiciona os parametros no vetor (na ordem correta)	param.addElement(new Byte(PACOTE_CONFIRMAR_ARQUIVO_RECEBIDO));	param.trimToSize();	this.iniciarServicoRede(param, true);	requestOK = MessageDispatcher.getRespostaServidor() == MessageDispatcher.RESPOSTA_OK;    }    /**     * Solicita o arquivo com os imóveis do roteiro ao servidor.     *      * @param login     *            Objeto que aguarda a resposta da operação.     */    public void baixarRoteiro() {	// cria o vetor de parâmetros	Vector param = new Vector();	// adiciona os parâmetros no vetor (na ordem correta)	param.addElement(new Byte(PACOTE_BAIXAR_ARQUIVO));	param.trimToSize();	this.iniciarServicoRede(param, true);	requestOK = MessageDispatcher.getRespostaServidor() == MessageDispatcher.RESPOSTA_OK;    }    /**     * Envia o arquivo gerado do imovel para o servidor     *      * @param Array     *            de bytes com o arquivo     */    public void enviarImovel(byte[] imovel) throws IOException {	// cria o vetor de parâmetros	Vector param = new Vector();	ByteArrayOutputStream bais = new ByteArrayOutputStream();	bais.write(PACOTE_ATUALIZAR_MOVIMENTO);	bais.write(imovel);	param.addElement(bais.toByteArray());	param.trimToSize();	this.iniciarServicoRede(param, false);	requestOK = MessageDispatcher.getRespostaServidor() == MessageDispatcher.RESPOSTA_OK;    }    /**     * Envia o arquivo gerado do imovel para o servidor     *      * @param Array     *            de bytes com o arquivo     */    public void finalizarLeitura(byte[] arquivoRetorno, short tipoFinalizacao) throws IOException {	// cria o vetor de parâmetros	Vector param = new Vector();	param.addElement(new Byte(PACOTE_FINALIZAR_LEITURA));	param.addElement(arquivoRetorno);	param.trimToSize();	this.iniciarServicoRede(param, true);	requestOK = MessageDispatcher.getRespostaServidor() == MessageDispatcher.RESPOSTA_OK;    }    public boolean isRequestOK() {	return requestOK;    }        /**     *      * Baixa o arquivo jad do servidor     *      * @author Bruno Barros     * @date 18/06/2010     */    public void baixarNovaVersaoJad() {	// cria o vetor de parâmetros	Vector param = new Vector();	// adiciona os parâmetros no vetor (na ordem correta)	param.addElement(new Byte( BAIXAR_NOVA_VERSAO_JAD ));	param.trimToSize();	this.iniciarServicoRede(param, true);	requestOK = MessageDispatcher.getRespostaServidor() == MessageDispatcher.RESPOSTA_OK;    }        /**     *      * Baixa o arquivo jar do servidor     *      * @author Bruno Barros     * @date 18/06/2010     */    public void baixarNovaVersaoJar() {	// cria o vetor de parâmetros	Vector param = new Vector();	// adiciona os parâmetros no vetor (na ordem correta)	param.addElement(new Byte( BAIXAR_NOVA_VERSAO_JAR ));	param.trimToSize();	this.iniciarServicoRede(param, true);	requestOK = MessageDispatcher.getRespostaServidor() == MessageDispatcher.RESPOSTA_OK;    }        }