/* * Copyright (C) 2007-2009 the GSAN - Sistema Integrado de Gestão de Serviços de Saneamento * * This file is part of GSAN, an integrated service management system for Sanitation * * GSAN is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License. * * GSAN is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA *//* * GSAN - SHA1Sistema Integrado de Gestão de Serviços de Saneamento * Copyright (C) <2007> * Adriano Britto Siqueira * Alexandre Santos Cabral * Ana Carolina Alves Breda * Ana Maria Andrade Cavalcante * Aryed Lins de Araújo * Bruno Leonardo Rodrigues Barros * Carlos Elmano Rodrigues Ferreira * Clêudio de Andrade Lira * Denys Guimarães Guenes Tavares * Eduardo Breckenfeld da Rosa Borges * Fabíola Gomes de Araújo * Flêvio Leonardo Cavalcanti Cordeiro * Francisco do Nascimento Júnior * Homero Sampaio Cavalcanti * Ivan Sérgio da Silva Júnior * José Edmar de Siqueira * José Thiago Tenório Lopes * Kássia Regina Silvestre de Albuquerque * Leonardo Luiz Vieira da Silva * Márcio Roberto Batista da Silva * Maria de Fátima Sampaio Leite * Micaela Maria Coelho de Araújo * Nelson Mendonça de Carvalho * Newton Morais e Silva * Pedro Alexandre Santos da Silva Filho * Rafael Corrêa Lima e Silva * Rafael Francisco Pinto * Rafael Koury Monteiro * Rafael Palermo de Araújo * Raphael Veras Rossiter * Roberto Sobreira Barbalho * Roberto Souza * Rodrigo Avellar Silveira * Rosana Carvalho Barbosa * Sávio Luiz de Andrade Cavalcante * Tai Mu Shih * Thiago Augusto Souza do Nascimento * Tiago Moreno Rodrigues * Vivianne Barbosa Sousa * * Este programa é software livre; você pode redistribuí-lo e/ou * modificá-lo sob os termos de Licença Pública Geral GNU, conforme * publicada pela Free Software Foundation; versão 2 da * Licença. * Este programa é distribuído na expectativa de ser útil, mas SEM * QUALQUER GARANTIA; sem mesmo a garantia implêcita de * COMERCIALIZAÇÃO ou de ADEQUAÇÃO A QUALQUER PROPÓSITO EM * PARTICULAR. Consulte a Licença Pública Geral GNU para obter mais * detalhes. * Você deve ter recebido uma cópia da Licença Pública Geral GNU * junto com este programa; se não, escreva para Free Software * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA * 02111-1307, USA. */package com.ipad.io;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.Enumeration;import java.util.Vector;import javax.microedition.io.Connector;import javax.microedition.io.file.FileConnection;import javax.microedition.io.file.FileSystemRegistry;import com.ipad.basic.Anormalidade;import com.ipad.basic.Configuracao;import com.ipad.basic.ImovelReg11;import com.ipad.basic.ImovelReg14;import com.ipad.component.Progress;import com.ipad.util.Constantes;import com.ipad.util.Util;import com.ipad.view.AbaHidrometroAgua;public class FileManager {    private static FileManager instancia;    private FileConnection fileConnectorArquivoImoveis;    private FileConnection fileConnectorArquivoRetorno;    private InputStream inputStreamArquivoImoveis;    private InputStream inputStreamArquivoRetorno;//    private static Vector anormalidadesSemHidrometro;    private static Vector anormalidadesIndicadorUso1;    private static Vector anormalidadesSemIndicadorUso1;//    private static boolean permitionGranted = true;    private static int LEITURA_CONFIRMADA = 99;       /**     * Valor decimal do código ascii para o Carriage-Return (enter). OBS.: O     * valor hexadecimal é 0D     */    private final static byte ENTER = 13;    /**     * Valor decimal do código ascii para o Line-Feed (pula linha).     */    private final static byte LINE = 10;    /**     * Valor retornado quando o final do arquivo é atingido.     */    private final static byte EOF = -1;    private static int indiceArquivoImoveis;    /**     * Modo de abertura de arquivo que só abre se já existir.     */    public static final int NAO_CRIAR = 1;    /**     * Caminho do cartão de memória.     */    public static String INPUT_FILE_PATH;// = "file:///e:/GComMovel/";    /**     * Modo de abertura de arquivo que cria o arquivo caso não exista.     */    public static final int CRIAR_SE_NAO_EXISTIR = 0;    /**     * Modo de abertura de arquivo que apaga antes de criar.     */    public static final int APAGAR_E_CRIAR = 2;    /**     * Modo de abertura de arquivo que apaga antes de criar.     */    public static final int APAGAR = 3;    /**     * Caminhos dos recursos. Raiz = /res/     */    private static final String RESOURCE_PATH = "/";    /**     * Nome do arquivo com os imóveis do roteiro.     */    private String nomeArquivo = null;    private String nomeArquivoImpressora = "impressora.txt";    // private Repositorio repositorio = Repositorio.getInstancia();    // private FileManager fileManager = FileManager.getInstancia();    /**     * Retorna um vetor com a lista de arquivos no diretório do GComMovel.     *      * @return Vetor com os nomes dos arquivos no diretório.     */    private FileManager() {		super();// Daniel - Tratamento de security exception	try{		descobrirRootsDispositivo();		this.nomeArquivo = Configuracao.getInstancia().getNomeArquivoImoveis();	} catch (SecurityException se){//		Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario! A aplicação será fechada!");		    			Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario!");		    	//		Fachada.getInstancia().exit();	}}    public Vector abrirDiretorio() {	// abre o diretório do GCom, criando ele caso ainda não exista	FileConnection fc = abrir(INPUT_FILE_PATH, true, CRIAR_SE_NAO_EXISTIR);	Vector response = new Vector();// Daniel - checar fc antes de manipular o conteudo	if(fc != null){		try {		    Enumeration e1 = fc.list("*.txt", false);		    while (e1.hasMoreElements()) {			response.addElement(e1.nextElement());		    }		    		    Enumeration e2 = fc.list("*.gz", false);		    while (e2.hasMoreElements()) {			response.addElement(e2.nextElement());		    }		    		} catch (IOException ex) {		    ex.printStackTrace();		} catch (SecurityException se){			// Daniel - Security Excepiton    		//			Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario! A aplicação será fechada!");		    				Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario!");		    	//			Fachada.getInstancia().exit();		}	}	// Daniel - close fileConnection	if (fc != null && fc.isOpen()) {		try {			fc.close();		} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}	}	fc = null;	return response;    }    /**     * Abre um arquivo ou diretório do sistema de arquivos do dispositivo.     *      * @param caminho     *            Caminho do arquivo ou diretório.     * @param diretorio     *            Identifica se é um diretório ou não.     * @param modo     *            Modo de abertura.     * @return Arquivo.     */    public static FileConnection abrir(String caminho, boolean diretorio, int modo) {	FileConnection fc = null;		try {	    switch (modo) {	    // só para arquivos	    case APAGAR_E_CRIAR:// Daniel - Impedir a geracao de exceções se usuario nao der permissao de leitura/escrita	    	try {			    fc = (FileConnection) Connector.open(caminho, Connector.READ_WRITE);			    if (fc.exists()) {				fc.delete();			    fc.close();			    fc = null;		    }		} catch (IOException ioe) {		} catch (SecurityException se){			// Daniel - Security Excepiton    		//			Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario! A aplicação será fechada!");		    				Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario!");		    	//			Fachada.getInstancia().exit();    		return fc;		}	    case CRIAR_SE_NAO_EXISTIR:	    	// Daniel - Impedir a geracao de exceçoes se usuario nao der permissao de leitura/escrita		try {		if (fc == null) {		    fc = (FileConnection) Connector.open(caminho);		}		if (!fc.exists()) {		    if (diretorio) {			fc.mkdir();		    } else {			fc.create();		    }		}		break;		} catch (IOException ioe) {		} catch (SecurityException se){			// Daniel - Security Excepiton    		//			Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario! A aplicação será fechada!");		    				Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario!");		    	//			Fachada.getInstancia().exit();    		return fc;//        } catch(IllegalArgumentException err) {//			// Daniel    		//    		Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario! A aplicação será fechada!");		    	//    		Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario!");		    	//    		Fachada.getInstancia().exit();//    		return fc;		}	    case NAO_CRIAR:	    	// Daniel - Impedir a geracao de exceçoes se usuario nao der permissao de leitura/escrita		try {		fc = (FileConnection) Connector.open(caminho, Connector.READ);		if (!fc.exists()) {		    fc.close();		    fc = null;		}		break;		} catch (IOException ioe) {		} catch (SecurityException se){			// Daniel - Security Excepiton    		//			Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario! A aplicação será fechada!");		    				Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario!");		    	//			Fachada.getInstancia().exit();    		return fc;		}	    case APAGAR:	    	// Daniel - Impedir a geracao de exceçoes se usuario nao der permissao de leitura/escrita			try {			    fc = (FileConnection) Connector.open(caminho);			    if (fc.exists()) {			    	fc.delete();			    }			    fc.close();			    fc = null;			} catch (IOException ioe) {			} catch (SecurityException se){				// Daniel - Security Excepiton    		//				Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario! A aplicação será fechada!");		    					Util.mostrarErro("Acesso de leitura não  autorizado pelo usuario!");		    	//				Fachada.getInstancia().exit();			}		}	} catch (Exception e) {	    e.printStackTrace();	    Util.mostrarErro( e.toString(), e );	}	return fc;    }    /**     * Abre um recurso. Ex.: Arquivo texto, imagens, etc.     *      * @param idRecurso     *            Identificador do recurso.     * @return Dados do recurso.     */    public InputStream abrirRecurso(int idRecurso) {	InputStream is = this.getClass().getResourceAsStream(RESOURCE_PATH + idRecurso);	return is;    }    public static FileManager getInstancia() {	if (instancia == null) {	    instancia = new FileManager();	}	return instancia;    }    /**     * Separa um arquivo texto por linhas.     *      * @param arquivo     *            Dados do arquivo texto.     * @param maxLinhas     *            Número máximo de linhas. Caso seja zero, retorna todas as     *            linhas     * @return Vetor de linhas do arquivo texto.     */    public Vector carregaVetorLinhas(InputStream arquivo, int maxLinhas) throws IOException {	Vector vetor = new Vector();	vetor.removeAllElements();	StringBuffer buffer = new StringBuffer();		int i = 0;	while (i != EOF && (maxLinhas == 0 || vetor.size() < maxLinhas)) {	    i = arquivo.read();		String line = buffer.toString();	    // System.out.println("Valor char: "+(char)i);	    // se for enter (0D ou 13)...	    if (i == ENTER) {		// ...pula para o próximo caractere		    i = arquivo.read();					    }	    // se for quebra linha (0A ou 10)...	    if (i == LINE || i == EOF) {		// ...salva o registro//		if ("".equals(line) || line == null ) {//			Daniel			if ("".equals(line) || line == null  || line.length()==0) {		    continue;		}		vetor.addElement(line);		buffer.delete(0, buffer.length());	    } else {		buffer.append((char) i);	    }	}	indiceArquivoImoveis += maxLinhas;	buffer = null;	return vetor;    }    public Vector lerArquivoImoveis() throws IOException {	// System.out.println("Input:"+INPUT_FILE_PATH);		if (fileConnectorArquivoImoveis == null || !fileConnectorArquivoImoveis.isOpen()) {	    fileConnectorArquivoImoveis = abrir(INPUT_FILE_PATH + nomeArquivo, false, NAO_CRIAR);	}		if ( (inputStreamArquivoImoveis == null) && (fileConnectorArquivoImoveis != null) ) {	    	    if ( nomeArquivo.endsWith( ".txt" ) ){	    		inputStreamArquivoImoveis = 		    //Util.inflateFile( 				fileConnectorArquivoImoveis.openInputStream();//, 				//(int) fileConnectorArquivoImoveis.fileSize() );	    } else {		inputStreamArquivoImoveis = 		    Util.inflateFile( 				fileConnectorArquivoImoveis.openInputStream(), 				(int) fileConnectorArquivoImoveis.fileSize() );			    }//Daniel	    fileConnectorArquivoImoveis.close();	    fileConnectorArquivoImoveis = null;	}		boolean response = (inputStreamArquivoImoveis != null);	Vector linhas = null;		if (response) {	    linhas = carregaVetorLinhas(inputStreamArquivoImoveis, 65);	    if (inputStreamArquivoImoveis != null && linhas.size() == 0) {		inputStreamArquivoImoveis.close();		inputStreamArquivoImoveis = null;	    }	}		return linhas;    }    /**     * Lê o arquivo de retorno e retorna um vetor com as linhas geradas.     *      * @author Bruno Barros     * @data 19/10/2009     * @return vetor com as linhas do arquivo de retorno     */    public Vector lerArquivoRetorno() throws IOException {		Vector linhas = null;		try{	    fileConnectorArquivoRetorno = abrir(Configuracao.getInstancia().getNomeArquivoRetorno(), false, NAO_CRIAR);// Daniel - checando se fileConnectorArquivoRetorno é null antes de acessa-lo.	    if ((inputStreamArquivoRetorno == null) && (fileConnectorArquivoRetorno != null)) {		inputStreamArquivoRetorno = fileConnectorArquivoRetorno.openInputStream();	    }	    	    boolean response = (inputStreamArquivoRetorno != null);	    	    if (response) {		linhas = carregaVetorLinhas(inputStreamArquivoRetorno, 0);		inputStreamArquivoRetorno.close();		inputStreamArquivoRetorno = null;	    }	} finally{	    if ( fileConnectorArquivoImoveis != null ){	    	fileConnectorArquivoImoveis.close();	    	fileConnectorArquivoImoveis=null;	    }	    	    if ( inputStreamArquivoImoveis != null ){			inputStreamArquivoImoveis.close();			inputStreamArquivoImoveis=null;	    }	    //Daniel	    fileConnectorArquivoRetorno.close();		fileConnectorArquivoRetorno = null;	}		return linhas;    }    public Vector lerArquivoImoveis( InputStream arquivo ) throws IOException {	// System.out.println("Input:"+INPUT_FILE_PATH);	inputStreamArquivoImoveis = arquivo;	boolean response = (inputStreamArquivoImoveis != null);	Vector linhas = null;	if (response) {	    linhas = carregaVetorLinhas(inputStreamArquivoImoveis, 65);	    if (inputStreamArquivoImoveis != null && linhas.size() == 0) {		inputStreamArquivoImoveis.close();		inputStreamArquivoImoveis = null;	    }	}	return linhas;    }    public String lerArquivoImpressora() throws IOException {	String retorno = "";	FileConnection fc = abrir(INPUT_FILE_PATH + nomeArquivoImpressora, false, NAO_CRIAR);	InputStream is = null;	if (fc != null){		is = fc.openInputStream();			}	boolean response = is != null;	Vector linhas = null;	if (response) {	    linhas = carregaVetorLinhas(is, 65);	    for (int i = 0; i < linhas.size(); i++) {		if (i == linhas.size() - 1) {		    retorno += linhas.elementAt(i);		} else {		    retorno += linhas.elementAt(i) + "\n";		}	    }	    if (is != null) {		is.close();		is = null;	    }	}//Daniel	fc.close();	fc = null;	return retorno;    }    public void descobrirRootsDispositivo() throws SecurityException {	String caminhoMemoryCard = System.getProperty("fileconn.dir.memorycard");	// String caminhoMemoryCard = System.getProperty("Fileconn.dir.tones");	if (caminhoMemoryCard == null || caminhoMemoryCard.trim().equals("")) {	    Enumeration roots = FileSystemRegistry.listRoots();	    String currentRoot = null;	    while (roots.hasMoreElements()) {		currentRoot = (String) roots.nextElement();	    }	    INPUT_FILE_PATH = "file:///" + currentRoot + "GComMovel/";	    // INPUT_FILE_PATH = currentRoot + "GComMovel/";	} else {	    INPUT_FILE_PATH = caminhoMemoryCard + "GComMovel/";	}    }    public void setNomeArquivo(String nomeArquivo) {	this.nomeArquivo = nomeArquivo;	Configuracao.getInstancia().setNomeArquivoImoveis(this.nomeArquivo);	Repositorio.salvarObjeto(Configuracao.getInstancia());    }    public static void salvarErro(Exception error) {	try {	    FileConnection fc = null;	    InputStream in = null;	    OutputStream out = null;	    fc = FileManager.abrir(FileManager.INPUT_FILE_PATH + "Log/", true, FileManager.CRIAR_SE_NAO_EXISTIR);	    if (fc != null){		    fc = FileManager.abrir(FileManager.INPUT_FILE_PATH + "Log/" + "log" + ".txt", false, FileManager.CRIAR_SE_NAO_EXISTIR);	// Daniel - checar conteudo de fc		    if (fc != null){			    in = fc.openInputStream();			    byte[] mensagensAntigas = new byte[(int) fc.fileSize()];			    in.read(mensagensAntigas);			    if (mensagensAntigas.length != 1) {			    	out = fc.openOutputStream();			    }			    out.write(mensagensAntigas);			    out.write((Util.dateToString(Util.dataAtual()) + " " + Util.dateToHoraString(Util.dataAtual()) + " - " + error.toString() + "\n").getBytes());		    }	    }	    out.close();	    in.close();	    fc.close();	    out = null;	    in = null;	    fc = null;	} catch (IOException e) {	    e.printStackTrace();	    Util.mostrarErro("Erro na criação do arquivo de retorno", e);	}    }// Daniel - new mwthod       public static void salvarLog(String message) {    	try {    	    FileConnection fc = null;    	    InputStream in = null;    	    OutputStream out = null;    	    fc = FileManager.abrir(FileManager.INPUT_FILE_PATH + "Log/", true, FileManager.CRIAR_SE_NAO_EXISTIR);	    	    if (fc != null){	    	    fc = FileManager.abrir(FileManager.INPUT_FILE_PATH + "Log/" + "operacoes" + ".txt", false, FileManager.CRIAR_SE_NAO_EXISTIR);	    	 // Daniel - checar conteudo de fc	    	    if (fc != null){		    	    in = fc.openInputStream();		    	    byte[] mensagensAntigas = new byte[(int) fc.fileSize()];		    	    in.read(mensagensAntigas);		    	    if (mensagensAntigas.length != 1) {		    	    	out = fc.openOutputStream();		    	    }		    	    out.write(mensagensAntigas);		    	    out.write((Util.dateToString(Util.dataAtual()) + " " + Util.dateToHoraString(Util.dataAtual()) + " - " + message + "\n").getBytes()); 	    	    	    }    	    }    	    out.close();    	    in.close();    	    fc.close();    	    out = null;    	    in = null;    	    fc = null;    	} catch (IOException e) {    	    e.printStackTrace();    	    Util.mostrarErro("Erro na criação do arquivo de log de operações", e);    	}        }    /**     * Carrega as anormalidades no controlador conta     */    public Vector carregarAnormalidades(boolean apenasComIndicadorUso1) throws IOException {		if ( apenasComIndicadorUso1 && anormalidadesIndicadorUso1 != null ){	    return anormalidadesIndicadorUso1;	} else if ( !apenasComIndicadorUso1 && anormalidadesSemIndicadorUso1 != null ){	    return anormalidadesSemIndicadorUso1;	} else {		    	    Vector anorm = null;	    // lê arquivo de anormalidades// Daniel - check if it's null first.	    if (ImovelReg14.getInstancia().getRegistros14() != null){			Vector anormalidades = ImovelReg14.getInstancia().getRegistros14();				// carrega os id's de cada anormalidade			Anormalidade[] anors = this.carregarVetorAnormalidades(anormalidades, apenasComIndicadorUso1);			// define lista de anormalidades			anorm = AbaHidrometroAgua.getInstancia().setAnormalidadesAgua(anors);			    if (apenasComIndicadorUso1) {			anormalidadesIndicadorUso1 = anorm;		    } else {			anormalidadesSemIndicadorUso1 = anorm;		    }	    }	    return anorm;	    	}    }    /**     * Carrega o array que mapeia o indice da anormalidade no identificador.     *      * @param anormalidades     *            Vetor de anormalidades.     */    public Anormalidade[] carregarVetorAnormalidades(Vector anormalidades, boolean apenasComIndicadorUso1) {	int len = anormalidades.size();	// Daniel- corrigindo vetor de anormalidades		Anormalidade[] retorno = new Anormalidade[anormalidades.size()+1];	Anormalidade anor = new Anormalidade();	anor.setCodigo(00);	anor.setDescricao("");	anor.setIndicadorLeitura(1);	anor.setIdConsumoACobrarComLeitura(1);	anor.setIdConsumoACobrarSemLeitura(0);	anor.setIdLeituraFaturarComLeitura(1);	anor.setIdLeituraFaturarSemLeitura(0);	anor.setIndcUso(Constantes.SIM);	anor.setNumeroFatorSemLeitura(Constantes.NULO_DOUBLE);	anor.setNumeroFatorComLeitura(Constantes.NULO_DOUBLE);		retorno[0] = anor;		int contador = 1;	// Daniel- corrigindo vetor de anormalidades		for (int i = 1; i < len+1 ; i++) {	    ImovelReg14 reg14 = (ImovelReg14) anormalidades.elementAt(i-1);// Daniel - Descarta Anormalidade LEITURA_CONFIRMADA - Usuario não pode usar tal opção.	    if (reg14.getCodigo() == LEITURA_CONFIRMADA){	    	len = len -1;	    	continue;	    }		anor = new Anormalidade();	    anor.setCodigo(reg14.getCodigo());	    anor.setDescricao(reg14.getDescricao());	    anor.setIndicadorLeitura(reg14.getIndicadorLeitura());	    anor.setIdConsumoACobrarComLeitura(reg14.getIdConsumoACobrarComLeitura());	    anor.setIdConsumoACobrarSemLeitura(reg14.getIdConsumoACobrarSemLeitura());	    anor.setIdLeituraFaturarSemLeitura(reg14.getIdLeituraFaturarSemLeitura());	    anor.setIdLeituraFaturarComLeitura(reg14.getIdLeituraFaturarComLeitura());	    anor.setIndcUso(reg14.getIndcUso());	    anor.setNumeroFatorSemLeitura(reg14.getNumeroFatorSemLeitura());		anor.setNumeroFatorComLeitura(reg14.getNumeroFatorComLeitura());	   	    int uso = reg14.getIndcUso();	    retorno[i] = anor;	    //retorno[i + 1] = anor;	    if (uso != 2) {		contador++;	    }	}	if (apenasComIndicadorUso1) {	    Anormalidade[] retornoIndicadorUsoSim = new Anormalidade[contador];	    contador = 0;	 // Daniel- corrigindo vetor de anormalidades		    for (int i = 0; i < len+1; i++) {		if (retorno[i].getIndcUso() == Constantes.SIM) {		    retornoIndicadorUsoSim[contador] = retorno[i];		    contador++;		}	    }	    return retornoIndicadorUsoSim;	} else {	    return retorno;	}    }    /**     * Carrega as anormalidades direto do arquivo     *      * @return vetor com as anormalidades     */    public static Vector getAnormalidades(boolean apenasComIndicadorUso1){		Vector anormalidades = new Vector();	try {	    if (ImovelReg11.getInstancia().getCodigoEmpresaFebraban().equals(Constantes.CODIGO_FEBRABAN_COSANPA)) {		anormalidades = FileManager.getInstancia().carregarAnormalidades(apenasComIndicadorUso1);		}	} catch (IOException e) {	    e.printStackTrace();	    Util.mostrarErro("Erro ao carregar arquivo de anormalidade");	}	return anormalidades;    }    /**     * Carrega as anormalidades sem hidrometro direto do arquivo     *      * @return vetor com as anormalidades     *///    public static Vector getAnormalidadesSemHidrometro() throws IOException {//	if (anormalidadesSemHidrometro == null) {//	    anormalidadesSemHidrometro = FileManager.getInstancia().carregarAnormalidades(Constantes.RES_ID_ARQ_ANORMALIDADES_SEM_HIDROMETRO, false);//	}//	return anormalidadesSemHidrometro;//    }    /**     * Retorna a anormalidade com o código pesquisado     *      * @param codigo     *            codigo da anormalidade     * @return se achar, retorna a anormalidade, senão nulo     */    public static Anormalidade getAnormalidade(int codigo) throws IOException {	Anormalidade anor = new Anormalidade();	anor.setCodigo(codigo);	Vector anormalidades = getAnormalidades(false);	int indice = anormalidades.indexOf(anor);	if (indice != -1) {	    return (Anormalidade) anormalidades.elementAt(indice);	} else {	    return null;	}    }    public static boolean verificarExistenciaArquivo(String nomeArquivo) {	// abre o diretório do GCom, criando ele caso ainda não exista	boolean result = false;//Daniel	FileConnection fc = abrir(nomeArquivo, true, NAO_CRIAR);	if (fc != null){		result = true;		try {			fc.close();			fc = null;		} catch (IOException e) {			e.printStackTrace();		}	}	return result;    }        /**     * Separa um arquivo texto por linhas.     *      * @param arquivo     *            Dados do arquivo texto.     * @param maxLinhas     *            Número máximo de linhas. Caso seja zero, retorna todas as     *            linhas     * @return Vetor de linhas do arquivo texto.     */    public byte[] carregaByteArrayAtualizandoProgressBar(InputStream arquivo, Progress p, int tamanhoArquivo ) throws IOException {		byte[] retorno = new byte[ tamanhoArquivo ];		int i = 0;	int contador = 0;		i = arquivo.read();		do{	    double d = (double) (contador+1) / tamanhoArquivo;	    byte percentual = (byte) ((d) * 100);	    p.setProgress(percentual);	    p.repaint();	    	    retorno[contador] = (byte)i;	    ++contador;	    	    i = arquivo.read();	} while ( i != EOF );		return retorno;    }}